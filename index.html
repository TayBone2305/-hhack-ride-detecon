<!DOCTYPE html>
<html lang="en">
<head>
<title>AirBike</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="style.css">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>

</head>
<body>
	<div class="app">
        <div class="map" id="map"></div>  
	</div>
<script type="text/javascript" src="script.js"></script>
<div id="map"></div>

<script>
	mapboxgl.accessToken = 'pk.eyJ1IjoibGVvbnNjaGxvdGUiLCJhIjoiY2xncjJvdDE4MDc4djNncXZ2emVhYWQ2ZiJ9.iWx09fUzgL36_OKOREUGAA';
const map = new mapboxgl.Map({
container: 'map', // container ID
// Choose from Mapbox's core styles, or make your own style with Mapbox Studio
style: 'mapbox://styles/mapbox/streets-v12', // style URL
center: [10.020099006029522, 53.55569974043304], // starting position [lng, lat]
zoom: 11, // starting zoom
doubleClickZoom: false,
dragPan: false,
dragRotate: false,
boxZoom: false,
scrollZoom: false
});


const marker2 = new mapboxgl.Marker({draggable: true}).setLngLat([10.02009, 53.5558]).addTo(map);
const marker1 = new mapboxgl.Marker({draggable: true}).setLngLat([10.02006, 53.5555]).addTo(map);






/*

function onDragEnd() {
const lngLat1 = marker1.getLngLat();
coordinates.style.display = 'block';
coordinates.innerHTML = `Longitude: ${lngLat1.lng}<br />Latitude: ${lngLat1.lat}`;
const lngLat2 = marker2.getLngLat();
coordinates.style.display = 'block';
coordinates.innerHTML = `Longitude: ${lngLat2.lng}<br />Latitude: ${lngLat2.lat}`;
}
marker1.on('dragend', onDragEnd);
marker2.on('dragend', onDragEnd);

*/

</script>


<script type="text/javascript">

var radwege = '';
var nodes = {};
var edges = {};
var graph = {};


  fetch("./Fahrradwege_routing.geojson")
.then(response => {
   return response.json();
})
.then((data) => {
	radwege = data

	for (let i = 0; i < radwege.features.length; i++) { 

		elem = radwege.features[i]

		edges[elem.properties.gml_id] = {
			'length': 1, 
			'geometry': elem.geometry,
			'start': elem.properties.source,
			'end': elem.properties.target
		}



		if (nodes[elem.properties.source] == undefined){
			nodes[elem.properties.source] = {'edges' : [elem.properties.gml_id], 'coordinates': elem.geometry.coordinates[0][0]}
		}else{
			nodes[elem.properties.source]['edges'].push(elem.properties.gml_id)
			//console.log(nodes[elem.properties.source]['edges'])
		}

		if (nodes[elem.properties.target] == undefined){
			nodes[elem.properties.target] = {'edges' : [elem.properties.gml_id], 'coordinates': elem.geometry.coordinates[0][elem.geometry.coordinates.length-1]}
		}else{
			nodes[elem.properties.target]['edges'].push(elem.properties.gml_id)
			//console.log(nodes[elem.properties.target]['edges'])
		}






		if (graph[elem.properties.source] == undefined){
			graph[elem.properties.source] = {}
			graph[elem.properties.source][elem.properties.target] = elem.properties.breite //todo: change to length
		}else{
			graph[elem.properties.source][elem.properties.target] = elem.properties.breite
			//console.log(nodes[elem.properties.source]['edges'])
		}


		if (graph[elem.properties.target] == undefined){
			graph[elem.properties.target] = {}
			graph[elem.properties.target][elem.properties.source] = elem.properties.breite
			//graph[elem.properties.target] = {elem.properties.source: elem.properties.breite} //todo: change to length
		}else{
			graph[elem.properties.target][elem.properties.source] = elem.properties.breite
			//console.log(nodes[elem.properties.source]['edges'])
		}
	}

});




let shortestDistanceNode = (distances, visited) => {
  // create a default value for shortest
	let shortest = null;
	
  	// for each node in the distances object
	for (let node in distances) {
    	// if no node has been assigned to shortest yet
  		// or if the current node's distance is smaller than the current shortest
		let currentIsShortest =
			shortest === null || distances[node] < distances[shortest];
        	
	  	// and if the current node is in the unvisited set
		if (currentIsShortest && !visited.includes(node)) {
            // update shortest to be the current node
			shortest = node;
		}
	}
	return shortest;
};


let findShortestPath = (graph, startNode, endNode) => {
 
  // track distances from the start node using a hash object
    let distances = {};
    distances[endNode] = "Infinity";
    distances = Object.assign(distances, graph[startNode]);
    // track paths using a hash object
    let parents = { endNode: null };
    for (let child in graph[startNode]) {
      parents[child] = startNode;
    }
 
   // collect visited nodes
   let visited = [];
   // find the nearest node
   let node = shortestDistanceNode(distances, visited);
 
    // for that node:
    while (node) {
       // find its distance from the start node & its child nodes
       let distance = distances[node];
       let children = graph[node]; 
 
       // for each of those child nodes:
       for (let child in children) {
 
          // make sure each child node is not the start node
          if (String(child) === String(startNode)) {
             continue;
          } else {
             // save the distance from start node to child node
             let newdistance = distance + children[child];
             // if there’s no recorded distance from the start node to the child node in the distances object
             // or if the recorded distance is shorter than the previously stored distance from the start node to the child node
             if (!distances[child] || distances[child] > newdistance) {
                // save the distance to the object
                distances[child] = newdistance;
                // record the path
                parents[child] = node;
            } 
         }
      } 
    // move the current node to the visited set
    visited.push(node);
   // move to the nearest neighbor node
   node = shortestDistanceNode(distances, visited);
   }
 
   // using the stored paths from start node to end node
   // record the shortest path
   let shortestPath = [endNode];
   let parent = parents[endNode];
   while (parent) {
      shortestPath.push(parent);
      parent = parents[parent];
   }
   shortestPath.reverse();
 
   //this is the shortest path
// return the shortest path & the end node’s distance from the start node
};


/*
function getClosestNode(search_coord){

	var best_option = '';
	var current_distance = 9999999;

	for id, elem in nodes.items(){
    	if ( best_option === '' || getDistance(search_coord, elem.coordinates) < current_distance ){

    		best_option = id

    	}
	}

	return best_option;
}

*/
function routing(coordA, coordB){

}

function getDistance(coordA, coordB){
	return 10; //should always be positive
}


</script>

</body>
</html>
